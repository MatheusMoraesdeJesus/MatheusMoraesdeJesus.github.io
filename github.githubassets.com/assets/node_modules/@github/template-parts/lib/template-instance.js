var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var _processor, _parts;
import {
    parse
} from './template-string-parser.js';
import {
    AttributeValueSetter,
    AttributeTemplatePart
} from './attribute-template-part.js';
import {
    NodeTemplatePart
} from './node-template-part.js';
import {
    propertyIdentity
} from './processors.js';

function* collectParts(el) {
    const walker = el.ownerDocument.createTreeWalker(el, NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT, null, false);
    let node;
    while ((node = walker.nextNode())) {
        if (node instanceof Element && node.hasAttributes()) {
            for (let i = 0; i < node.attributes.length; i += 1) {
                const attr = node.attributes.item(i);
                if (attr && attr.value.includes('{{')) {
                    const valueSetter = new AttributeValueSetter(node, attr);
                    for (const token of parse(attr.value)) {
                        if (token.type === 'string') {
                            valueSetter.append(token.value);
                        } else {
                            const part = new AttributeTemplatePart(valueSetter, token.value);
                            valueSetter.append(part);
                            yield part;
                        }
                    }
                }
            }
        } else if (node instanceof Text && node.textContent && node.textContent.includes('{{')) {
            for (const token of parse(node.textContent)) {
                if (token.end < node.textContent.length)
                    node.splitText(token.end);
                if (token.type === 'part')
                    yield new NodeTemplatePart(node, token.value);
                break;
            }
        }
    }
}
export class TemplateInstance extends DocumentFragment {
    constructor(template, params, processor = propertyIdentity) {
        var _a, _b;
        super();
        _processor.set(this, void 0);
        _parts.set(this, void 0);
        // This is to fix an inconsistency in Safari which prevents us from
        // correctly sub-classing DocumentFragment.
        // https://bugs.webkit.org/show_bug.cgi?id=195556
        if (Object.getPrototypeOf(this !== TemplateInstance.prototype)) {
            Object.setPrototypeOf(this, TemplateInstance.prototype);
        }
        this.appendChild(template.content.cloneNode(true));
        __classPrivateFieldSet(this, _parts, Array.from(collectParts(this)));
        __classPrivateFieldSet(this, _processor, processor);
        (_b = (_a = __classPrivateFieldGet(this, _processor)).createCallback) === null || _b === void 0 ? void 0 : _b.call(_a, this, __classPrivateFieldGet(this, _parts), params);
    }
    update(params) {
        __classPrivateFieldGet(this, _processor).processCallback(this, __classPrivateFieldGet(this, _parts), params);
    }
}
_processor = new WeakMap(), _parts = new WeakMap();
//# sourceMappingURL=template-instance.js.map
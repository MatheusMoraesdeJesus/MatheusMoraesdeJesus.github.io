// Parse HTML text into document fragment.
function parseHTML(document, html) {
    const template = document.createElement('template');
    template.innerHTML = html;
    return document.importNode(template.content, true);
}

function serialize(form) {
    const params = new URLSearchParams();
    const entries = new FormData(form).entries();
    for (const [name, value] of [...entries]) {
        params.append(name, value.toString());
    }
    return params.toString();
}
export class ErrorWithResponse extends Error {
    constructor(message, response) {
        super(message);
        this.response = response;
    }
}

function makeDeferred() {
    let resolve;
    let reject;
    const promise = new Promise(function(_resolve, _reject) {
        resolve = _resolve;
        reject = _reject;
    });
    return [promise, resolve, reject];
}
let formHandlers;
const afterHandlers = [];
const beforeHandlers = [];
export function afterRemote(fn) {
    afterHandlers.push(fn);
}
export function beforeRemote(fn) {
    beforeHandlers.push(fn);
}
export function remoteForm(selector, fn) {
    if (!formHandlers) {
        formHandlers = new Map();
        document.addEventListener('submit', handleSubmit);
    }
    const handlers = formHandlers.get(selector) || [];
    formHandlers.set(selector, [...handlers, fn]);
}
export function remoteUninstall(selector, fn) {
    if (formHandlers) {
        const handlers = formHandlers.get(selector) || [];
        formHandlers.set(selector, handlers.filter(x => x !== fn));
    }
}

function getMatches(el) {
    const results = [];
    for (const selector of formHandlers.keys()) {
        if (el.matches(selector)) {
            const handlers = formHandlers.get(selector) || [];
            results.push(...handlers);
        }
    }
    return results;
}

function handleSubmit(event) {
    if (!(event.target instanceof HTMLFormElement)) {
        return;
    }
    const form = event.target;
    const matches = getMatches(form);
    if (matches.length === 0) {
        return;
    }
    const req = buildRequest(form);
    const [kickerPromise, ultimateResolve, ultimateReject] = makeDeferred();
    event.preventDefault();
    processHandlers(matches, form, req, kickerPromise).then(async (performAsyncSubmit) => {
        if (performAsyncSubmit) {
            for (const handler of beforeHandlers) {
                await handler(form);
            }
            // TODO: ensure that these exceptions are processed by our global error handler
            remoteSubmit(req)
                .then(ultimateResolve, ultimateReject)
                // eslint-disable-next-line @typescript-eslint/no-empty-function
                .catch(() => {})
                .then(() => {
                    for (const handler of afterHandlers) {
                        handler(form);
                    }
                });
        } else {
            // No handler called the kicker function
            form.submit();
        }
    }, (err) => {
        // TODO: special "cancel" error object to halt processing and avoid
        // submitting the form
        form.submit();
        setTimeout(() => {
            throw err;
        });
    });
}
// Process each handler sequentially until it either completes or calls the
// kicker function.
async function processHandlers(matches, form, req, kickerPromise) {
    let kickerWasCalled = false;
    for (const match of matches) {
        const [kickerCalled, kickerCalledResolve] = makeDeferred();
        const kick = () => {
            kickerWasCalled = true;
            kickerCalledResolve();
            return kickerPromise;
        };
        const kicker = {
            text: kick,
            json: () => {
                req.headers.set('Accept', 'application/json');
                return kick();
            },
            html: () => {
                req.headers.set('Accept', 'text/html');
                return kick();
            }
        };
        await Promise.race([kickerCalled, match(form, kicker, req)]);
    }
    return kickerWasCalled;
}

function buildRequest(form) {
    const req = {
        method: form.method || 'GET',
        url: form.action,
        headers: new Headers({
            'X-Requested-With': 'XMLHttpRequest'
        }),
        body: null
    };
    if (req.method.toUpperCase() === 'GET') {
        const data = serialize(form);
        if (data) {
            req.url += (~req.url.indexOf('?') ? '&' : '?') + data;
        }
    } else {
        req.body = new FormData(form);
    }
    return req;
}
async function remoteSubmit(req) {
    const response = await window.fetch(req.url, {
        method: req.method,
        body: req.body !== null ? req.body : undefined,
        headers: req.headers,
        credentials: 'same-origin'
    });
    const res = {
        url: response.url,
        status: response.status,
        statusText: response.statusText,
        headers: response.headers,
        text: '',
        get json() {
            // eslint-disable-next-line no-shadow, @typescript-eslint/no-this-alias
            const response = this;
            const data = JSON.parse(response.text);
            delete response.json;
            response.json = data;
            return response.json;
        },
        get html() {
            // eslint-disable-next-line no-shadow, @typescript-eslint/no-this-alias
            const response = this;
            delete response.html;
            response.html = parseHTML(document, response.text);
            return response.html;
        }
    };
    const body = await response.text();
    res.text = body;
    if (response.ok) {
        return res;
    } else {
        throw new ErrorWithResponse('request failed', res);
    }
}
//# sourceMappingURL=index.js.map
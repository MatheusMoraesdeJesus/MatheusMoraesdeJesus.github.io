function e(e) {
    const t = "==".slice(0, (4 - e.length % 4) % 4),
        n = e.replace(/-/g, "+").replace(/_/g, "/") + t,
        r = atob(n),
        o = new ArrayBuffer(r.length),
        c = new Uint8Array(o);
    for (let e = 0; e < r.length; e++) c[e] = r.charCodeAt(e);
    return o
}

function t(e) {
    const t = new Uint8Array(e);
    let n = "";
    for (const e of t) n += String.fromCharCode(e);
    return btoa(n).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "")
}

function n(e, t, r) {
    if ("copy" === t) return r;
    if ("convert" === t) return e(r);
    if (t instanceof Array) return r.map((r => n(e, t[0], r)));
    if (t instanceof Object) {
        const o = {};
        for (const [c, i] of Object.entries(t))
            if (c in r) null != r[c] ? o[c] = n(e, i.schema, r[c]) : o[c] = null;
            else if (i.required) throw new Error("Missing key: " + c);
        return o
    }
}

function r(e) {
    return {
        required: !0,
        schema: e
    }
}

function o(e) {
    return {
        required: !1,
        schema: e
    }
}
const c = {
        type: r("copy"),
        id: r("convert"),
        transports: o("copy")
    },
    i = {
        appid: o("copy"),
        appidExclude: o("copy"),
        credProps: o("copy")
    },
    a = {
        appid: o("copy"),
        appidExclude: o("copy"),
        credProps: o("copy")
    },
    s = {
        publicKey: r({
            rp: r("copy"),
            user: r({
                id: r("convert"),
                name: r("copy"),
                displayName: r("copy")
            }),
            challenge: r("convert"),
            pubKeyCredParams: r("copy"),
            timeout: o("copy"),
            excludeCredentials: o([c]),
            authenticatorSelection: o("copy"),
            attestation: o("copy"),
            extensions: o(i)
        }),
        signal: o("copy")
    },
    p = {
        type: r("copy"),
        id: r("copy"),
        rawId: r("convert"),
        response: r({
            clientDataJSON: r("convert"),
            attestationObject: r("convert")
        }),
        clientExtensionResults: r(a)
    },
    l = {
        mediation: o("copy"),
        publicKey: r({
            challenge: r("convert"),
            timeout: o("copy"),
            rpId: o("copy"),
            allowCredentials: o([c]),
            userVerification: o("copy"),
            extensions: o(i)
        }),
        signal: o("copy")
    },
    u = {
        type: r("copy"),
        id: r("copy"),
        rawId: r("convert"),
        response: r({
            clientDataJSON: r("convert"),
            authenticatorData: r("convert"),
            signature: r("convert"),
            userHandle: r("convert")
        }),
        clientExtensionResults: r(a)
    };
export const schema = {
    credentialCreationOptions: s,
    publicKeyCredentialWithAttestation: p,
    credentialRequestOptions: l,
    publicKeyCredentialWithAssertion: u
};
export async function create(r) {
    return function(e) {
        const r = e;
        return r.clientExtensionResults = e.getClientExtensionResults(), n(t, p, r)
    }(await navigator.credentials.create(function(t) {
        return n(e, s, t)
    }(r)))
}
export async function get(r) {
    return function(e) {
        const r = e;
        return r.clientExtensionResults = e.getClientExtensionResults(), n(t, u, r)
    }(await navigator.credentials.get(function(t) {
        return n(e, l, t)
    }(r)))
}
export function supported() {
    return !!(navigator.credentials && navigator.credentials.create && navigator.credentials.get && window.PublicKeyCredential)
}
//# sourceMappingURL=webauthn-json.js.map